// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma multi_compile __ changeNormalMap
#pragma multi_compile __ changeMaskMap
#pragma multi_compile __ changeColor

RWTexture2D<float4> DefectMapInOut;
Texture2D<float4> rustMask;

#if changeColor 
    RWTexture2D<float4> ColorMapInOut;
    float4 colorRust1;
    float4 colorRust2;
#endif
#if changeNormalMap
    RWTexture2D<float4> NormalMapInOut;
    float dentModifier;
#endif
#if changeMaskMap
    RWTexture2D<float4> MaskMapInOut;
    float metalicnessOffset;
#endif

float maskZoom; //higher number means more zoomed out => more changes
float rustPaternZoom; //higher number means more zoomed out => more changes
float xSkew; //skew the rust patern zoom in x direction
float rustCoMin; 
float rustCoMax;
uint nrOfOctaves; //higher number means more detail in simplex noise


//forward declarations
#include "RandomGPU.compute"

// function that makes a fast but smooth transition between 0 and 1
// the function returns 1 when x is between rustCoMin and rustCoMax
// https://www.desmos.com/calculator/1ak13sbgml
float easeFunction(float x)
{
    const float sharpness = 200;
    

    float lower_sigmoid = 1 / (1 + exp(-sharpness * (x - rustCoMin)));
    float upper_sigmoid = 1 / (1 + exp( sharpness * (x - rustCoMax)));

    return lower_sigmoid * upper_sigmoid;
}

float3 unpackNormal(float4 packedNormal){
    float3 normal;
    normal.xy = packedNormal.wy * 2 - 1;
    normal.z = sqrt(1 - (dot(normal.xy, normal.xy)));
    return normal;
}
float4 packNormal(float3 normal)
{
    float4 packedNormal;
    packedNormal.xyzw = normal.zyzx * 0.5f + 0.5f;
    return packedNormal;
}

float2 noiseDerivatives(uint2 co, int2 resolution)
{
    //todo find analyticly
	float rustCo = (rustCoMin + rustCoMax) / 2;
    uint threadRandSeed = randSeed;//reset seed for each lookup
    float prevX = FractalBrownianMotion(nrOfOctaves, maskZoom, xSkew, threadRandSeed, co + int2(-1, 0), resolution);
    prevX = prevX * easeFunction(prevX);
    threadRandSeed = randSeed;
    float nextX = FractalBrownianMotion(nrOfOctaves, maskZoom, xSkew, threadRandSeed, co + int2(1, 0), resolution);
    nextX = nextX * easeFunction(nextX);
    threadRandSeed = randSeed;
    float prevY = FractalBrownianMotion(nrOfOctaves, maskZoom, xSkew, threadRandSeed, co + int2(0, -1), resolution);
    prevY = prevY * easeFunction(prevY);
    threadRandSeed = randSeed;
    float nextY = FractalBrownianMotion(nrOfOctaves, maskZoom, xSkew, threadRandSeed, co + int2(0, 1), resolution);
    nextY = nextY * easeFunction(nextY);
    
    return float2(nextX - prevX, -nextY + prevY);// y needs to be reversed for the normal map
}



[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{   
    uint threadRandSeed = createThreadRandomSeed(id.xy, randSeed);
    uint startRandSeed = randSeed;
    int2 resolution;
    rustMask.GetDimensions(resolution.x, resolution.y);
    
    rustCoMin = rustCoMax - ((rustCoMax - rustCoMin) / 2) * rustMask[id.xy].b;
    float rustValue = FractalBrownianMotion(nrOfOctaves, maskZoom, xSkew, randSeed, id.xy, resolution);
    float rustAge = FractalBrownianMotion(nrOfOctaves, rustPaternZoom, xSkew, randSeed, id.xy, resolution);
    //float stepRustValue = step(rustValue, rustCoMax);
    //stepRustValue *= step(rustCoMin, rustValue);
    float stepRustValue = easeFunction(rustValue);
    
    #if changeColor 
        float4 oldColor = ColorMapInOut[id.xy];
        float4 newColor = lerp(colorRust1, colorRust2, saturate(rustAge));
        ColorMapInOut[id.xy] = float4(lerp(oldColor, newColor, newColor.a * stepRustValue).rgb, 1);
    #endif
    
    // 1 = no defect; 0 = defect
    float4 defectMapValue = DefectMapInOut[id.xy];
    defectMapValue.a = defectMapValue.a * (1 - stepRustValue);
    DefectMapInOut[id.xy] = defectMapValue;
    
    #if changeMaskMap 
        float4 oldMask = MaskMapInOut[id.xy];
        oldMask.r += stepRustValue * metalicnessOffset; //metalicness
        oldMask.a *= 1 - stepRustValue * 0.4; //reduce smoothness
        MaskMapInOut[id.xy] = saturate(oldMask);
    #endif
    
    #if changeNormalMap 
        randSeed = startRandSeed;
        float3 rustNormal = float3(noiseDerivatives(id.xy, resolution) * 2, 0) * dentModifier;
        float normalNoiseModifier = 0.01f;
        //rustNormal.xy += (float2(nextRand(threadRandSeed), nextRand(threadRandSeed)) - 0.5f) * normalNoiseModifier * stepRustValue;
        rustNormal.z = 0.0f;
     
        float3 oldNormal = unpackNormal(NormalMapInOut[id.xy]);
        float3 newNormal = normalize(rustNormal + oldNormal);
        NormalMapInOut[id.xy] = packNormal(newNormal);
#endif
}


